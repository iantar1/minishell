parsing
note : 	implement a queue that will help a lot. (optional)
		implement a garbage collector (optional)

0. first of all you have to implement **get_env** and **set_env**
basically you have to copy the environment variable from the main function to a custom
environment variable that you'll make. (static (technique of mlx)).
- get_env()
- get_env_var(key)
- set_env(key, value) don't handle the case of duplication or syntax error...
	(you're a parser).
1. tokenization

	for tokenization you have to make a function the take two params (a mask, a string)
	mask	contains only 0, 1 or 2
	string	....

	mask	0000010000010
	string	hello world .
	result	[hello, world, .]

	the mask above will tell the function to split the string by space.

	mask	0020100121010012010012210
	string	ls>a ls > a ls >a ls >> r
	result	[ls, >, a, ls, >, a, ls, >, a, ls, >>, r]

	the mask above will tell the function to split the string by > and space. By distinguishing > and space using 1 for space and 2 for > we can do a special action, that we can eliminate space from the split result and keep the >

	this is it
	1: for split and eliminate
	2: for split and keep
	0: keep

	----------------------------------------------

	now you have to make a function that you give it one parameter and it will generate a mask as follow.
	1 will detect space and tab outside the '' or ""
	2 will detect > < | outside the '' or ""

	example:
	string		ls>>>a | echo 'ls > a |" hhhh' ||| ls < a
	output_musk	00222012100001000000000000000012221001210

	if you give that mask to the previous function it will generate this list

	[ls, >>|, a, |, echo, 'ls > a |" hhhh', ||, ' " ', |||, ls, <, a]

	example2:
	string		ls 'ls ' hhh'
	output_mask	0010000010000
	result		[ls, 'ls ', hhh']


2. check syntax

	lets take for examples this output list
	[ls, >>>, a, |, echo, 'ls > a |" hhhh', |||, ls, <, a, hhh']

	1. you have to check for > < >> << | '' and ""
		one > or two >> not three or more >>>
		one < or two << not three or more <<<
		one | not *three* (two is acceptable by bash) or more, not positioned in the first or the last in the list
		||
		&&
		'' "" they should be closed

	2. so for every item in the list you have to call the right function
		ordinary string function to check "" ''
		>>>>>..... function to check > >>
		<<<<<..... function to check < <<
		|||.... function to check |

	3. function for check if there is a pipe in the first or the last

3. expand the $ values from the env (you have to implement get_env, and set_env=export)

	for example lets take a valid list as follow
	[l$t"$empty", |, $r, |, echo, "$r", '$r']
	if t=s and r=cat and empty not defined
	[ls"", |, cat, |, echo, "cat", '$r']

4. remove the quote
	example for the list above
	[ls, |, cat, |, echo, cat, $r]

5. check for this rule
	every > < >> << has to be followed by name or defined $env_var (>$empty is not acceptable test it yourself)

6. build the command structure
	command [args*] [<file] [>file] [<<heredoc] [>>file] | anther *args* ....

	struct node:
		char *command_name;
		list of args;
		int fd_in = 0 or the file descriptor of the last file with < or the file descriptor of the herdoc (if file herdoc approach was implemented rather than pipe approach);
		int fd_out = 1 or the file descriptor of the last file with >;

	the result is an array or list of node command
	[node1, node2, node3, ..., nodeN, NULL]

	----------------------------------------------

	herdoc 
	1. a herdoc with a single quot or double quot will not substitute the value of $env (test it)
	herdoc can be implement with tow methed (file approach(recommended by bash) or pipe apprach)

ls>>>>>>>>a       'ls $r'> a'
00222222220111111100000202100
[ls',>>>>>>>>,' a, 'ls > $ra', >,  a']
[]