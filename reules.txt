# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    reules.txt                                         :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: iantar <iantar@student.1337.ma>            +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2023/04/10 02:58:53 by iantar            #+#    #+#              #
#    Updated: 2023/05/01 14:31:37 by iantar           ###   ########.fr        #
#                                                                              #
# **************************************************************************** #


II. EXPANDING:

	1)""  ;  here_doc  ;  ''  ;   "''"   ;   $?   ;   here_doc with "" and ''   ; 

III. REMOVE THE QUOTE.

	1) "" ''
		"hello world" -> hello world
		'"hi"' -> "hi"
		""''""hi""'' -> hi
	2)_here_doc_
		"hello -> store hello  and shore your here_doc and store any input , and show the output after 
					typing " which is the limiter.
		'hello -> the limiter is '





IV. HERE_DOC:

	1) reform the cmd line (if it needs) : cmd fil1 fil2 << lim1 file3 <<lim2 fil4 ... ->  cmd fil1 ...file4 ... << lim1 <<lim2
	2) if the is at least one file open the here_docs and send the commad and the fils.
	3) if there is no files, open all here_docs and send the  cmd the last and here_doc_file 
	4) chck first for the here_doc after that check for the syntax. 

V. REDIRACTIN: > < >>
	1) ambiguous redirect:
		.) ls > $tkhrbi9 ...
		
		..)ls > $var (var = "a  b")
	2) reform the command 
		cat < first -b  				==	cat -b < first
		cat < first -b second			==	cat -b second < first
		cat -b second < first outfile1	==	cat -b second outfile1 < first

		 ------------------------------------------------------------
		| cmd < arg1 arg2 arg3 ...  <==>	cmd arg2 arg3 ... < arg1 | 
		| cmd > arg1 arg2 arg3 ...	<==>	cmd arg2 arg3 ... > arg1 | ---> the same with >>
		| cmd arg1 > arg2 arg3 ...	<==>	cmd arg1 arg3 ... > arg2 |
		 ------------------------------------------------------------






VI. INPLEMENT THE TREE:
	1) check for ()
		-> who has the first priority.
	2) '|' has high priority then  '||' and  '&&'
	2). '>' has high priority then '|'
	3) the cmd will execute in the child or the parent process: { (cd) in child and cd in the parent } 

	--> after checking the syntax, split the "line" read from stdin into chunks to be execute 
		.)How to split:
			- evrything inside () musut be in one string.
			- split with || and && outside the (). they have the sme priority.
			- split with |
		example:
			  (ls || cat file) && echo "hello" && (ls | cat > outfile)
		mark: 00000000000000001220000010000000122100000000000000000000
		split:->{(ls || cat file), &&, echo, "hello", && (ls | cat > outfile)}
		the tree:
																							 &&
													╭─────────────────────────────────────────┴────────────────────────────────────────╮

									(ls || cat file) && echo "hello"															(ls | cat > outfile)
			
												&&																		  			     |
							╭───────────────────┴──────────────────╮  												 ╭───────────────────┴──────────────────╮					 

					(ls || cat file)						 echo "hello"    										ls 	  					    	  cat > outfile
							||
			╭────────────────┴───────────────╮
			ls								cat file




 --------------------------------------------------------------------------------------------------------------------------------------------------------
| Importent1:                                                                                                                                             |
|			In Bash, double parentheses (( )) are used for arithmetic evaluation. When you enclose a command in double parentheses,                       |
|			Bash evaluates the command as an arithmetic expression, which means that it attempts to perform mathematical calculations with the command.   |
| In your example ((ls)), Bash will attempt to evaluate ls as an arithmetic expression. However, since ls is not a mathematical expression, it will return|
| an error.                                                                                                                                               |
|                                                                                                                                                         |
| Importent2:   																																		  |
|	>>>>> open the here_doc before checking the syntax 																									  |
|	                                                                                                                                         			  |
 ---------------------------------------------------------------------------------------------------------------------------------------------------------


 .)	'<' or '>' + file_name





-> multiple rediractions <infile1 <infile2 <infile3 .... >outfile1 >outfile2 ....
-> here_doc
---> amniguous redirect
---> syntax error
->-> parce the tree.
-> more than 16 here-document : 
		printf("bash: maximum here-document count exceeded\n");
		exit(2);
		
IMPORTANT:
		-> in here_doc evrything will expand '"$USER"' -> '"iantar"'....
		-> don't expand the lim. 
		-> don't forget to edit the expanding fun : export a="    jk" 
			echo "$a" or "'$a'" is deffrent than $a 
			but in the here_doc they save the space : so edit just the expanding fun becouse you 
			use it in here doc too.
		-> don't forget the signals in here_doc.
		-> ls > file > fil1 > fil2 ... -> open all of them and send the last one
		-> add the wirldcard function.
				

AMBIGUOUS REDIRECT:
	
✅ var="     "
			> $var : split with SPACE if (and remove QUOTES) to the redirect_file = ""$var) if split[0] = NULL and remove QUOTES if ther is no QUOTE near var like "'"$var -> ambiguous
			> ""$var
			> """"$var""""''''""

✅ var="a    "
			> $var-

✅ var="     a"
			> b$var
 
✅ var doesn't exist
			> $var


NOT:

✅ var doesn't exist; > ""$var / > ''$var / > ""''""$var""'' / > " "$var
✅ var=""; > " "$var ; ""$var
⬜ -->>> wirldcard if (lst_size() > 1) --> ambiguous


VII. SYNTAX ERROR:

	1) (cmd1) <seperate> (cmd2) : <seperate> must be || or | or && otherwise syntax error.
	2) ((..((cmd))..)) : it's an error but dosn't show any message , just the exit status = 1
	✅ () : syntax error 
	4) create a function to check |||.. and &&&... syntax errors.
	5) check for single & and &&&... |||... 
	6) a commad ling start with logic operators.
	8) ls > (l > k > o > p): > + ( : syntax error



✅	> |
✅	> ||
✅	> (file)
✅	> &&
✅  &&&.. or |||... or & or >>> <<<
✅ (ls) (ls): (cmd...) (cmd...) must be separate by a symbole 
✅(cmd) cmd... 
✅ unclosed " '
✅ unclosed ()
✅ >< <>
✅ (ls) < file ls arg1 arg2 .... : use the reforme function.
✅ ;



NOT:
	|| >
	| >
	(cmd) > file or (cmd) < file

IMPORTANT:
	in syntax_error , exit with 258
	if (fork() == 0)
		exit(258);


✅For (): parenthesis must not be empty
✅Before (): Pipe or logical operator or or spaces nothing 
✅After (): Pipe or logical operator or redirection or spaces(No arguments)
✅Pipe and logical operators must be neither the first nor the last
✅Redirections must not be the last.
✅redirections are allowed after logical operators, and no other two neighboring operators are valid.



SOLUTION : 
		-> splti with | || && (after checking that they are valid)
			 * eliminate all the space 111111...
			 * check for ")(" and 
			 * ")" + 'char' or 'char' + "(": char can be anything exepte | & > < 
			 ----->>> if you find it -> STOP.
		-> split with > or < or >> or << (after checking that they are valid)
			 * if you find in the next NULL or | or || or && : STOP

✅ check : char	*mark_redirection(char *str, int sp); diff between  > and '>'



IMPORTANT:
	to do list:
		✅ (ls) > ouc -al : syntax_error
		✅ check expanding and make it run
		⛔ signal in here_doc and check its expanding too.
		⛔ nominette
		⛔ wirldcard in ambiguous functin.
		✅ remove_quotes
		⛔ leaks
		⛔ check ambiguous_redirect after merging.
		✅ > file1 file2 file3 ...-> reform_redirection
		✅ cmd > file1 > file2 > file3 .. -> open all of them  (and close) and send the last  
		✅ cat <<l <oyyr >> oudc <oiyg > oj
		⛔ modify_var("?", "1")
		⛔ check all strcmp() fun, you might miss that it return 0 when they are the same.
		⛔ HERE_DOC: there is a problem, and 
		⛔ check if all $ inside "" ''  
		⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔check when the file is creating (before expanding awlidi)⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔⛔
		⛔((cat -n | wc -n) > out || (cat || ls -l || pp))
		⛔ls > $var (it create then it expand : PROBLEM)
		⛔$PATH$
		⛔ > "$var" and > $var : don't remove the QUOTES untile you check for "a  b" 
		⛔ft_expanding , line 217
		⛔ WORNING: reform_redirection ls > " " : "   " is one arg not two
		⛔the problem of tomorrow : ls > "a     b"
		⛔what will happend if we have error || > file1 > file2: you must not create them
		⛔ while openning a her_doc and you press ctrl+c , what will happend to the file that you create.
		⛔⛔⛔⛔⛔⛔⛔⛔⛔ what the hell is that: ls>1>2 , ls > 1 > 2, ls >o>o
		⛔⛔⛔⛔⛔⛔⛔⛔  cat < mjhgh < file: open it first if open = -1, send it, becouse it dosn't existe.
		⛔print errors in 2
		⛔

 parcing/reform_rediraction.c  |   6 ++--


TOMORROW : <<L || <<L || ....:   it must send one here_doc between two && || 


cat <<l | > o cat <<l
> cat | > o <<l