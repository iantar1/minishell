I. SPLIT YOUR STRING

	1)   >  <  | : 11111

	2)   >> <<   : 22222

	3)   ||   && : 22222

	4)   <> and >< : ask first how they work, and test them.

	5)   " " and ' ' 

	6)    $

	7)    |||... &&&... : 3333 : syntax error

	ls>file||cat file2&&
	00200002200010000022

 II. EXPANDING:

	1)""  ;  here_doc  ;  ''  ;   "''"   ;   $?   ;   here_doc with "" and ''   ; 

III. REMOVE THE QUOTE.

	1) "" ''
		"hello world" -> hello world
		'"hi"' -> "hi"
		""''""hi""'' -> hi
	2)_here_doc_
		"hello -> store hello  and shore your here_doc and store any input , and show the output after 
					typing " which is the limiter.
		'hello -> the limiter is '







 ------------------------
| input: fd_infile or 0  |
|                        | -> it must be in your struct.
| outpud:fd_outfile or 1 |
 ------------------------



IV. HERE_DOC:

	1) reform the cmd line (if it needs) : cmd fil1 fil2 << lim1 file3 <<lim2 fil4 ... ->  cmd fil1 ...file4 ... << lim1 <<lim2
	2) if the is at least one file open the here_docs and send the commad and the fils.
	3) if there is no files, open all here_docs and send the  cmd the last and here_doc_file 
	4) chck first for the here_doc after that check for the syntax. 

V. REDIRACTIN: > < >>
	1) ambiguous redirect:
		.) ls > $tkhrbi9 ...
		
		..)
	2) reform the command 
		cat < first -b  				==	cat -b < first
		cat < first -b second			==	cat -b second < first
		cat -b second < first outfile1	==	cat -b second outfile1 < first

		 ------------------------------------------------------------
		| cmd < arg1 arg2 arg3 ...  <==>	cmd arg2 arg3 ... < arg1 | 
		| cmd > arg1 arg2 arg3 ...	<==>	cmd arg2 arg3 ... > arg1 | ---> the same with >>
		| cmd arg1 > arg2 arg3 ...	<==>	cmd arg1 arg3 ... > arg2 |
		 ------------------------------------------------------------






VI. INPLEMENT THE TREE:
	1) check for ()
		-> who has the first priority.
	2) '|' has high priority then  '||' and  '&&'
	2). '>' has high priority then '|'
	3) the cmd will execute in the child or the parent process: { (cd) in child and cd in the parent } 

	--> after checking the syntax, split the "line" read from stdin into chunks to be execute 
		.)How to split:
			- evrything inside () musut be in one string.
			- split with || and && outside the (). they have the sme priority.
			- split with |
		example:
			  (ls || cat file) && echo "hello" && (ls | cat > outfile)
		mark: 00000000000000001220000010000000122100000000000000000000
		split:->{(ls || cat file), &&, echo, "hello", && (ls | cat > outfile)}
		the tree:
																							 &&
													╭─────────────────────────────────────────┴────────────────────────────────────────╮

									(ls || cat file) && echo "hello"															(ls | cat > outfile)
			
												&&																		  			     |
							╭───────────────────┴──────────────────╮  												 ╭───────────────────┴──────────────────╮					 

					(ls || cat file)						 echo "hello"    										ls 	  					    	  cat > outfile
							||
			╭────────────────┴───────────────╮
			ls								cat file




 --------------------------------------------------------------------------------------------------------------------------------------------------------
| Importent1:                                                                                                                                             |
|			In Bash, double parentheses (( )) are used for arithmetic evaluation. When you enclose a command in double parentheses,                       |
|			Bash evaluates the command as an arithmetic expression, which means that it attempts to perform mathematical calculations with the command.   |
| In your example ((ls)), Bash will attempt to evaluate ls as an arithmetic expression. However, since ls is not a mathematical expression, it will return|
| an error.                                                                                                                                               |
|                                                                                                                                                         |
| Importent2:   																																		  |
|	>>>>> open the here_doc before checking the syntax 																									  |
|	                                                                                                                                         			  |
 ---------------------------------------------------------------------------------------------------------------------------------------------------------


 .)	'<' or '>' + file_name


VII. SYNTAX ERROR:
	1) (cmd1) <seperate> (cmd2) : <seperate> must be || or | or && otherwise syntax error.
	2) ((cmd)) : it's an error but dosn't show any message , just the exit status = 1
	3) () : syntax error 
	4) create a function to check |||.. and &&&... syntax errors.
	5) check for single & and &&&... |||... 
	6) a commad ling start with logic operators.
	7) ambiguous redirect: ls > $rtfh ...
	8) ls > (l > k > o > p): > + ( : syntax error



-> multiple rediractions <infile1 <infile2 <infile3 .... >outfile1 >outfile2 ....
-> here_doc
-> amniguous redirect
-> syntax error
->-> parce the tree.
-> more than 16 here-document : 
		printf("bash: maximum here-document count exceeded\n");
		exit(2);
		
IMPORTANT:
		-> in here_doc evrything will expand '"$USER"' -> '"iantar"'....
		-> don't expand the lim. 